// Assets/Scripts/Input/UserInput.cs
using UnityEngine;
using UnityEngine.InputSystem;
using UnityEngine.UI;
using UnityEngine.SceneManagement; // Added to resolve Scene and LoadSceneMode types
using System.Collections;
using System.Collections.Generic;

public class UserInput : MonoBehaviour
{
    // Singleton Instance
    public static UserInput instance;

    // Controls generated by Unity's Input System
    [HideInInspector] public Controls controls;

    // Player movement inputs
    [HideInInspector] public Vector2 moveInput;
    [HideInInspector] public float verticalInput;

    // UI reference to display the current skill icon
    [SerializeField] private Image currentSkillIconUI;

    // Skill icons for selectable skills (assign in Inspector)
    [SerializeField] private Sprite fireballIcon;
    [SerializeField] private Sprite attackSkill2Icon;
    [SerializeField] private Sprite hpSkill2Icon;
    [SerializeField] private Sprite mpSkill2Icon;
    [SerializeField] private Sprite stealthSkill1Icon;
    [SerializeField] private Sprite fireballSkill2Icon;

    // Container for skill icons (assign in Inspector)
    [SerializeField] private Transform skillUIContainer; // Ensure this is assigned in the Inspector
    [SerializeField] private GameObject skillIconPrefab; // Ensure this is assigned in the Inspector

    private List<SelectableSkill> availableSkills = new List<SelectableSkill>();
    private int currentSkillIndex = 0;

    // Debounce flags to prevent multiple rapid triggers
    private bool canChangeSkill = true;
    private float debounceTime = 0.2f; // 200 milliseconds
    private Coroutine debounceCoroutine;

    private void Awake()
    {
        // Implement Singleton Pattern
        if (instance == null)
        {
            instance = this;
            DontDestroyOnLoad(gameObject);

            // Initialize the Controls instance
            controls = new Controls();

            // Subscribe to movement input events
            controls.Movement.Move.performed += OnMovePerformed;
            controls.Movement.Move.canceled += OnMoveCanceled;

            // Subscribe to grapple action event
            controls.GrapplingHook.Grapple.performed += OnGrapplePerformed;

            // Subscribe to skill selector input events
            controls.SkillSelector.NextSkill.performed += OnNextSkillPerformed;
            controls.SkillSelector.PreviousSkill.performed += OnPreviousSkillPerformed;
            controls.SkillSelector.UseSkill.performed += OnUseSelectedSkillPerformed;

            // Subscribe to scene loaded event
            SceneManager.sceneLoaded += OnSceneLoaded;
        }
        else
        {
            Destroy(gameObject); // Ensure only one instance exists
            return;
        }
    }
    /// <summary>
    /// Disables all player controls.
    /// </summary>
    public void DisableControls()
    {
        controls.Disable();
        Debug.Log("Player controls disabled.");
    }

    /// <summary>
    /// Enables all player controls.
    /// </summary>
    public void EnableControls()
    {
        controls.Enable();
        Debug.Log("Player controls enabled.");
    }

    private void OnEnable()
    {
        controls.Enable();
        RefreshAvailableSkills();
    }

    private void OnDisable()
    {
        controls.Disable();
    }

    private void OnDestroy()
    {
        // Unsubscribe from sceneLoaded event to prevent memory leaks
        SceneManager.sceneLoaded -= OnSceneLoaded;
    }

    /// <summary>
    /// Callback for when a new scene is loaded.
    /// Reassigns the CurrentSkillIcon UI reference.
    /// </summary>
    /// <param name="scene">The scene that was loaded.</param>
    /// <param name="mode">The mode in which the scene was loaded.</param>
    private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
    {
        Debug.Log($"Scene {scene.name} loaded. Reassigning CurrentSkillIcon UI.");

        // Find the CanvasHPAndDodgeAndMana GameObject in the new scene
        GameObject canvas = GameObject.Find("CanvasHPAndDodgeAndMana");
        if (canvas != null)
        {
            // Find the CurrentSkillIcon child
            Transform currentSkillIconTransform = canvas.transform.Find("CurrentSkillIcon");
            if (currentSkillIconTransform != null)
            {
                // Get the Image component
                Image skillIconImage = currentSkillIconTransform.GetComponent<Image>();
                if (skillIconImage != null)
                {
                    currentSkillIconUI = skillIconImage;
                    Debug.Log("CurrentSkillIcon UI reassigned successfully.");
                    UpdateCurrentSkillUI(); // Update the UI to reflect the current skill
                }
                else
                {
                    Debug.LogError("Image component not found on CurrentSkillIcon.");
                }
            }
            else
            {
                Debug.LogError("CurrentSkillIcon not found under CanvasHPAndDodgeAndMana.");
            }
        }
        else
        {
            Debug.LogError("CanvasHPAndDodgeAndMana not found in the loaded scene.");
        }

        // Refresh available skills in case any changes occurred
        RefreshAvailableSkills();
    }

    /// <summary>
    /// Callback for when the Move action is performed.
    /// Updates both horizontal and vertical inputs.
    /// </summary>
    /// <param name="context">Input action context.</param>
    private void OnMovePerformed(InputAction.CallbackContext context)
    {
        Vector2 input = context.ReadValue<Vector2>();
        moveInput = new Vector2(input.x, 0f); // Horizontal movement
        verticalInput = input.y;              // Vertical movement
    }

    /// <summary>
    /// Callback for when the Move action is canceled.
    /// Resets both horizontal and vertical inputs to zero.
    /// </summary>
    /// <param name="context">Input action context.</param>
    private void OnMoveCanceled(InputAction.CallbackContext context)
    {
        moveInput = Vector2.zero;
        verticalInput = 0f;
    }

    /// <summary>
    /// Checks if the Use action was triggered.
    /// </summary>
    /// <returns>True if Use action was triggered; otherwise, false.</returns>
    public bool IsUseActionTriggered()
    {
        return controls.Use.Use.triggered;
    }

    /// <summary>
    /// Checks if the Use HP Flask action was triggered.
    /// </summary>
    /// <returns>True if Use HP Flask action was triggered; otherwise, false.</returns>
    public bool IsUseHPFlaskActionTriggered()
    {
        return controls.UseHPFlask.UseHPFlask.triggered;
    }

    /// <summary>
    /// Checks if the Use MP Flask action was triggered.
    /// </summary>
    /// <returns>True if Use MP Flask action was triggered; otherwise, false.</returns>
    public bool IsUseMPFlaskActionTriggered()
    {
        return controls.UseMPFlask.UseMPFlask.triggered;
    }

    /// <summary>
    /// Checks if the Grapple action was triggered.
    /// </summary>
    /// <returns>True if Grapple action was triggered; otherwise, false.</returns>
    public bool IsGrappleActionTriggered()
    {
        return controls.GrapplingHook.Grapple.triggered;
    }

    /// <summary>
    /// Clears all input states by resetting movement and vertical inputs to zero.
    /// </summary>
    public void ClearInputStates()
    {
        moveInput = Vector2.zero;
        verticalInput = 0f;
        Debug.Log("Input states cleared.");
    }

    /// <summary>
    /// Callback for when the Grapple action is performed.
    /// Triggers the Grapple action in PlayerManager.
    /// </summary>
    /// <param name="context">Input action context.</param>
    private void OnGrapplePerformed(InputAction.CallbackContext context)
    {
        Debug.Log("Grapple action triggered.");
        PlayerManager.Instance.AttemptGrapple();
    }

    // Skill selector methods
    private void OnNextSkillPerformed(InputAction.CallbackContext context)
    {
        if (!canChangeSkill) return;

        if (availableSkills.Count == 0) return;
        currentSkillIndex = (currentSkillIndex + 1) % availableSkills.Count;
        UpdateCurrentSkillUI();

        // Start debounce
        StartDebounce();
    }

    private void OnPreviousSkillPerformed(InputAction.CallbackContext context)
    {
        if (!canChangeSkill) return;

        if (availableSkills.Count == 0) return;
        currentSkillIndex--;
        if (currentSkillIndex < 0) currentSkillIndex = availableSkills.Count - 1;
        UpdateCurrentSkillUI();

        // Start debounce
        StartDebounce();
    }

    private void OnUseSelectedSkillPerformed(InputAction.CallbackContext context)
    {
        if (availableSkills.Count == 0) return;
        SelectableSkill currentSkill = availableSkills[currentSkillIndex];
        UseSkill(currentSkill);
    }

    /// <summary>
    /// Refreshes the available skills from PlayerManager and updates the UI.
    /// </summary>
    public void RefreshAvailableSkills()
    {
        availableSkills = PlayerManager.Instance.GetUnlockedSelectableSkills();
        if (availableSkills.Count == 0)
        {
            if (currentSkillIconUI != null)
                currentSkillIconUI.sprite = null;
            return;
        }

        currentSkillIndex = 0;
        UpdateCurrentSkillUI();
    }

    /// <summary>
    /// Updates the current skill icon UI based on the selected skill.
    /// </summary>
    private void UpdateCurrentSkillUI()
    {
        if (availableSkills.Count > 0 && currentSkillIconUI != null)
        {
            SelectableSkill currentSkill = availableSkills[currentSkillIndex];
            currentSkillIconUI.sprite = GetSkillIcon(currentSkill);
            Debug.Log($"Current Skill UI updated to: {currentSkill}");
        }
        else
        {
            if (currentSkillIconUI != null)
                currentSkillIconUI.sprite = null;
        }
    }

    /// <summary>
    /// Retrieves the corresponding sprite for a given skill.
    /// </summary>
    /// <param name="skill">The skill to get the icon for.</param>
    /// <returns>The sprite associated with the skill.</returns>
    private Sprite GetSkillIcon(SelectableSkill skill)
    {
        switch (skill)
        {
            case SelectableSkill.Fireball: return fireballIcon;
            case SelectableSkill.AttackSkill2: return attackSkill2Icon;
            case SelectableSkill.HPSkill2: return hpSkill2Icon;
            case SelectableSkill.MPSkill2: return mpSkill2Icon;
            case SelectableSkill.StealthSkill1: return stealthSkill1Icon;
            case SelectableSkill.FireballSkill2: return fireballSkill2Icon;
            default: return null;
        }
    }

    /// <summary>
    /// Uses the selected skill by invoking corresponding actions in PlayerManager or Player.
    /// </summary>
    /// <param name="skill">The skill to use.</param>
    private void UseSkill(SelectableSkill skill)
    {
        // Use the corresponding skill via PlayerManager
        switch (skill)
        {
            case SelectableSkill.Fireball:
                // Ensure that Player.CastSpell() is public in Player.cs
                Player player = FindObjectOfType<Player>();
                if (player != null)
                {
                    player.CastSpell();
                }
                else
                {
                    Debug.LogWarning("Player not found in the scene.");
                }
                break;
            case SelectableSkill.AttackSkill2:
                PlayerManager.Instance.TryActivateAttackSkill();
                break;
            case SelectableSkill.HPSkill2:
                PlayerManager.Instance.TryActivateHPSkill();
                break;
            case SelectableSkill.MPSkill2:
                PlayerManager.Instance.TryActivateMPSkill();
                break;
            case SelectableSkill.StealthSkill1:
                PlayerManager.Instance.TryActivateStealthSkill();
                break;
            case SelectableSkill.FireballSkill2:
                PlayerManager.Instance.TryActivatePowerSkill();
                break;
            default:
                Debug.LogWarning("Unknown skill type attempted to use.");
                break;
        }
    }

    /// <summary>
    /// Starts a debounce timer to prevent multiple rapid skill changes.
    /// </summary>
    private void StartDebounce()
    {
        canChangeSkill = false;
        if (debounceCoroutine != null)
        {
            StopCoroutine(debounceCoroutine);
        }
        debounceCoroutine = StartCoroutine(Debounce());
    }

    /// <summary>
    /// Coroutine to handle the debounce timing.
    /// </summary>
    /// <returns>IEnumerator for coroutine.</returns>
    private IEnumerator Debounce()
    {
        yield return new WaitForSeconds(debounceTime);
        canChangeSkill = true;
    }
}
