//------------------------------------------------------------------------------
// <auto-generated>
//     This code was auto-generated by com.unity.inputsystem:InputActionCodeGenerator
//     version 1.11.2
//     from Assets/Scripts/Input/Controls.inputactions
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine.InputSystem;
using UnityEngine.InputSystem.Utilities;

public partial class @Controls: IInputActionCollection2, IDisposable
{
    public InputActionAsset asset { get; }
    public @Controls()
    {
        asset = InputActionAsset.FromJson(@"{
    ""name"": ""Controls"",
    ""maps"": [
        {
            ""name"": ""Movement"",
            ""id"": ""1ebf78a1-e681-4d4a-964d-2afda65937a8"",
            ""actions"": [
                {
                    ""name"": ""Move"",
                    ""type"": ""PassThrough"",
                    ""id"": ""33b108f7-175e-4dff-86a9-b85082b0692d"",
                    ""expectedControlType"": ""Vector2"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                }
            ],
            ""bindings"": [
                {
                    ""name"": ""WASD"",
                    ""id"": ""a61a500f-a25b-42fa-90bf-222d51db4e1a"",
                    ""path"": ""2DVector(mode=1)"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Move"",
                    ""isComposite"": true,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": ""up"",
                    ""id"": ""bc348bf0-2501-4371-b795-6a392b2ffdb0"",
                    ""path"": ""<Keyboard>/w"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard"",
                    ""action"": ""Move"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""down"",
                    ""id"": ""12a92a13-e785-47de-844e-a07091d3a79b"",
                    ""path"": ""<Keyboard>/s"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard"",
                    ""action"": ""Move"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""left"",
                    ""id"": ""9e684320-817f-4175-be7e-545fcabf4595"",
                    ""path"": ""<Keyboard>/a"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard"",
                    ""action"": ""Move"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""right"",
                    ""id"": ""b958e8da-bbf5-4c67-aeab-3124c8dbeba3"",
                    ""path"": ""<Keyboard>/d"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard"",
                    ""action"": ""Move"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""Arrow Keys"",
                    ""id"": ""33234bdc-3425-4172-9ab7-50d4fc104739"",
                    ""path"": ""2DVector(mode=1)"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Move"",
                    ""isComposite"": true,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": ""up"",
                    ""id"": ""f06e0312-76bf-4426-9a9f-5a4e7ba5f93c"",
                    ""path"": ""<Keyboard>/upArrow"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard"",
                    ""action"": ""Move"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""down"",
                    ""id"": ""192cad9d-69fa-4768-bfb5-a6840605a367"",
                    ""path"": ""<Keyboard>/downArrow"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard"",
                    ""action"": ""Move"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""left"",
                    ""id"": ""d4becbe9-e2ef-4aae-84d2-24f4a0cf7723"",
                    ""path"": ""<Keyboard>/leftArrow"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard"",
                    ""action"": ""Move"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""right"",
                    ""id"": ""88def1f2-2418-478c-a8e8-1bb01edd9ab9"",
                    ""path"": ""<Keyboard>/rightArrow"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard"",
                    ""action"": ""Move"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                }
            ]
        },
        {
            ""name"": ""Jumping"",
            ""id"": ""f4cfa6b9-4410-466e-812f-dde8c25212ae"",
            ""actions"": [
                {
                    ""name"": ""Jump"",
                    ""type"": ""PassThrough"",
                    ""id"": ""14ad7985-c4e6-4183-8048-afb2e54aaa9d"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                }
            ],
            ""bindings"": [
                {
                    ""name"": """",
                    ""id"": ""9da7b849-31a1-4708-9abf-ccd05870a86b"",
                    ""path"": ""<Keyboard>/space"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard"",
                    ""action"": ""Jump"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""f7910cb1-7106-4747-b662-d17404395300"",
                    ""path"": """",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Jump"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                }
            ]
        },
        {
            ""name"": ""Attack"",
            ""id"": ""b9d5c983-5330-4d49-91d2-852d402e8d60"",
            ""actions"": [
                {
                    ""name"": ""Attack"",
                    ""type"": ""PassThrough"",
                    ""id"": ""78100be8-e1a7-4162-af9e-8c08df7a37bc"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                }
            ],
            ""bindings"": [
                {
                    ""name"": """",
                    ""id"": ""34d973c1-55b4-41a6-91f0-47be8f61d3cf"",
                    ""path"": ""<Mouse>/leftButton"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard"",
                    ""action"": ""Attack"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""cf7a4a9b-5beb-4476-b550-4bbae41b8b40"",
                    ""path"": ""<Keyboard>/k"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard"",
                    ""action"": ""Attack"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                }
            ]
        },
        {
            ""name"": ""Dodge"",
            ""id"": ""62de9a47-b998-46c7-ad01-970dc2545efd"",
            ""actions"": [
                {
                    ""name"": ""Dodge"",
                    ""type"": ""PassThrough"",
                    ""id"": ""668f1976-e83a-4c98-a28b-e07a79ce6808"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                }
            ],
            ""bindings"": [
                {
                    ""name"": """",
                    ""id"": ""ce5405cd-2b70-4cce-9fde-4672599c4289"",
                    ""path"": ""<Keyboard>/shift"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard"",
                    ""action"": ""Dodge"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                }
            ]
        },
        {
            ""name"": ""Use"",
            ""id"": ""6bd455ef-b3aa-4cfb-8c52-1ac8cc26b54b"",
            ""actions"": [
                {
                    ""name"": ""Use"",
                    ""type"": ""PassThrough"",
                    ""id"": ""7054d791-d0be-4d3f-9d03-c80186b00beb"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                }
            ],
            ""bindings"": [
                {
                    ""name"": """",
                    ""id"": ""d78027eb-8d6a-42e4-87ac-a5f6b9e9283e"",
                    ""path"": ""<Keyboard>/f"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard"",
                    ""action"": ""Use"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                }
            ]
        },
        {
            ""name"": ""GrapplingHook"",
            ""id"": ""78580774-7a6d-4bed-b65f-b733e154902e"",
            ""actions"": [
                {
                    ""name"": ""Grapple"",
                    ""type"": ""PassThrough"",
                    ""id"": ""d6687572-7104-488f-9e94-988d1541b536"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                }
            ],
            ""bindings"": [
                {
                    ""name"": """",
                    ""id"": ""8e279548-7d8e-4c22-9fd1-b301544072b4"",
                    ""path"": ""<Keyboard>/t"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard"",
                    ""action"": ""Grapple"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""ea1aa55d-b4f5-49bb-88ec-3af81796fc13"",
                    ""path"": ""<Mouse>/rightButton"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Grapple"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                }
            ]
        },
        {
            ""name"": ""SkillSelector"",
            ""id"": ""60ee3c44-d8a1-4b63-a6f3-a06d96e3085d"",
            ""actions"": [
                {
                    ""name"": ""UseSkill"",
                    ""type"": ""PassThrough"",
                    ""id"": ""4c477b35-157d-499f-8517-4e5b0a7b55db"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""NextSkill"",
                    ""type"": ""PassThrough"",
                    ""id"": ""2e28aed6-d960-4bd9-868d-156ab923c118"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""PreviousSkill"",
                    ""type"": ""PassThrough"",
                    ""id"": ""8335a0b1-a6dd-4ce9-a9b2-b8aa54b7aa64"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                }
            ],
            ""bindings"": [
                {
                    ""name"": """",
                    ""id"": ""97933408-eaf8-4392-929a-9da336aced05"",
                    ""path"": ""<Keyboard>/r"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard"",
                    ""action"": ""UseSkill"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""89bc99b3-1ee6-4067-b1b0-7a00df55768a"",
                    ""path"": ""<Keyboard>/1"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard"",
                    ""action"": ""NextSkill"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""18305292-15ed-435f-8cdf-fa692e962d38"",
                    ""path"": ""<Keyboard>/2"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard"",
                    ""action"": ""PreviousSkill"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                }
            ]
        },
        {
            ""name"": ""Use HP Flask"",
            ""id"": ""402430a2-bd83-4a3c-927e-42f961dc1e02"",
            ""actions"": [
                {
                    ""name"": ""Use HP Flask"",
                    ""type"": ""PassThrough"",
                    ""id"": ""344b7916-cf54-4d45-b365-2e08030fdd49"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                }
            ],
            ""bindings"": [
                {
                    ""name"": """",
                    ""id"": ""ab46a46e-6db2-4a31-b838-765402f551ff"",
                    ""path"": ""<Keyboard>/q"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard"",
                    ""action"": ""Use HP Flask"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                }
            ]
        },
        {
            ""name"": ""Use MP Flask"",
            ""id"": ""a32925ba-f226-422a-867b-aafe4c5ae526"",
            ""actions"": [
                {
                    ""name"": ""Use MP Flask"",
                    ""type"": ""PassThrough"",
                    ""id"": ""517d8d61-5fb4-49e5-8521-c085184b7573"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                }
            ],
            ""bindings"": [
                {
                    ""name"": """",
                    ""id"": ""fa823135-a587-47c0-8ead-5e557192f49a"",
                    ""path"": ""<Keyboard>/e"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard"",
                    ""action"": ""Use MP Flask"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                }
            ]
        }
    ],
    ""controlSchemes"": [
        {
            ""name"": ""Keyboard"",
            ""bindingGroup"": ""Keyboard"",
            ""devices"": []
        },
        {
            ""name"": ""Gamepad"",
            ""bindingGroup"": ""Gamepad"",
            ""devices"": []
        }
    ]
}");
        // Movement
        m_Movement = asset.FindActionMap("Movement", throwIfNotFound: true);
        m_Movement_Move = m_Movement.FindAction("Move", throwIfNotFound: true);
        // Jumping
        m_Jumping = asset.FindActionMap("Jumping", throwIfNotFound: true);
        m_Jumping_Jump = m_Jumping.FindAction("Jump", throwIfNotFound: true);
        // Attack
        m_Attack = asset.FindActionMap("Attack", throwIfNotFound: true);
        m_Attack_Attack = m_Attack.FindAction("Attack", throwIfNotFound: true);
        // Dodge
        m_Dodge = asset.FindActionMap("Dodge", throwIfNotFound: true);
        m_Dodge_Dodge = m_Dodge.FindAction("Dodge", throwIfNotFound: true);
        // Use
        m_Use = asset.FindActionMap("Use", throwIfNotFound: true);
        m_Use_Use = m_Use.FindAction("Use", throwIfNotFound: true);
        // GrapplingHook
        m_GrapplingHook = asset.FindActionMap("GrapplingHook", throwIfNotFound: true);
        m_GrapplingHook_Grapple = m_GrapplingHook.FindAction("Grapple", throwIfNotFound: true);
        // SkillSelector
        m_SkillSelector = asset.FindActionMap("SkillSelector", throwIfNotFound: true);
        m_SkillSelector_UseSkill = m_SkillSelector.FindAction("UseSkill", throwIfNotFound: true);
        m_SkillSelector_NextSkill = m_SkillSelector.FindAction("NextSkill", throwIfNotFound: true);
        m_SkillSelector_PreviousSkill = m_SkillSelector.FindAction("PreviousSkill", throwIfNotFound: true);
        // Use HP Flask
        m_UseHPFlask = asset.FindActionMap("Use HP Flask", throwIfNotFound: true);
        m_UseHPFlask_UseHPFlask = m_UseHPFlask.FindAction("Use HP Flask", throwIfNotFound: true);
        // Use MP Flask
        m_UseMPFlask = asset.FindActionMap("Use MP Flask", throwIfNotFound: true);
        m_UseMPFlask_UseMPFlask = m_UseMPFlask.FindAction("Use MP Flask", throwIfNotFound: true);
    }

    ~@Controls()
    {
        UnityEngine.Debug.Assert(!m_Movement.enabled, "This will cause a leak and performance issues, Controls.Movement.Disable() has not been called.");
        UnityEngine.Debug.Assert(!m_Jumping.enabled, "This will cause a leak and performance issues, Controls.Jumping.Disable() has not been called.");
        UnityEngine.Debug.Assert(!m_Attack.enabled, "This will cause a leak and performance issues, Controls.Attack.Disable() has not been called.");
        UnityEngine.Debug.Assert(!m_Dodge.enabled, "This will cause a leak and performance issues, Controls.Dodge.Disable() has not been called.");
        UnityEngine.Debug.Assert(!m_Use.enabled, "This will cause a leak and performance issues, Controls.Use.Disable() has not been called.");
        UnityEngine.Debug.Assert(!m_GrapplingHook.enabled, "This will cause a leak and performance issues, Controls.GrapplingHook.Disable() has not been called.");
        UnityEngine.Debug.Assert(!m_SkillSelector.enabled, "This will cause a leak and performance issues, Controls.SkillSelector.Disable() has not been called.");
        UnityEngine.Debug.Assert(!m_UseHPFlask.enabled, "This will cause a leak and performance issues, Controls.UseHPFlask.Disable() has not been called.");
        UnityEngine.Debug.Assert(!m_UseMPFlask.enabled, "This will cause a leak and performance issues, Controls.UseMPFlask.Disable() has not been called.");
    }

    public void Dispose()
    {
        UnityEngine.Object.Destroy(asset);
    }

    public InputBinding? bindingMask
    {
        get => asset.bindingMask;
        set => asset.bindingMask = value;
    }

    public ReadOnlyArray<InputDevice>? devices
    {
        get => asset.devices;
        set => asset.devices = value;
    }

    public ReadOnlyArray<InputControlScheme> controlSchemes => asset.controlSchemes;

    public bool Contains(InputAction action)
    {
        return asset.Contains(action);
    }

    public IEnumerator<InputAction> GetEnumerator()
    {
        return asset.GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }

    public void Enable()
    {
        asset.Enable();
    }

    public void Disable()
    {
        asset.Disable();
    }

    public IEnumerable<InputBinding> bindings => asset.bindings;

    public InputAction FindAction(string actionNameOrId, bool throwIfNotFound = false)
    {
        return asset.FindAction(actionNameOrId, throwIfNotFound);
    }

    public int FindBinding(InputBinding bindingMask, out InputAction action)
    {
        return asset.FindBinding(bindingMask, out action);
    }

    // Movement
    private readonly InputActionMap m_Movement;
    private List<IMovementActions> m_MovementActionsCallbackInterfaces = new List<IMovementActions>();
    private readonly InputAction m_Movement_Move;
    public struct MovementActions
    {
        private @Controls m_Wrapper;
        public MovementActions(@Controls wrapper) { m_Wrapper = wrapper; }
        public InputAction @Move => m_Wrapper.m_Movement_Move;
        public InputActionMap Get() { return m_Wrapper.m_Movement; }
        public void Enable() { Get().Enable(); }
        public void Disable() { Get().Disable(); }
        public bool enabled => Get().enabled;
        public static implicit operator InputActionMap(MovementActions set) { return set.Get(); }
        public void AddCallbacks(IMovementActions instance)
        {
            if (instance == null || m_Wrapper.m_MovementActionsCallbackInterfaces.Contains(instance)) return;
            m_Wrapper.m_MovementActionsCallbackInterfaces.Add(instance);
            @Move.started += instance.OnMove;
            @Move.performed += instance.OnMove;
            @Move.canceled += instance.OnMove;
        }

        private void UnregisterCallbacks(IMovementActions instance)
        {
            @Move.started -= instance.OnMove;
            @Move.performed -= instance.OnMove;
            @Move.canceled -= instance.OnMove;
        }

        public void RemoveCallbacks(IMovementActions instance)
        {
            if (m_Wrapper.m_MovementActionsCallbackInterfaces.Remove(instance))
                UnregisterCallbacks(instance);
        }

        public void SetCallbacks(IMovementActions instance)
        {
            foreach (var item in m_Wrapper.m_MovementActionsCallbackInterfaces)
                UnregisterCallbacks(item);
            m_Wrapper.m_MovementActionsCallbackInterfaces.Clear();
            AddCallbacks(instance);
        }
    }
    public MovementActions @Movement => new MovementActions(this);

    // Jumping
    private readonly InputActionMap m_Jumping;
    private List<IJumpingActions> m_JumpingActionsCallbackInterfaces = new List<IJumpingActions>();
    private readonly InputAction m_Jumping_Jump;
    public struct JumpingActions
    {
        private @Controls m_Wrapper;
        public JumpingActions(@Controls wrapper) { m_Wrapper = wrapper; }
        public InputAction @Jump => m_Wrapper.m_Jumping_Jump;
        public InputActionMap Get() { return m_Wrapper.m_Jumping; }
        public void Enable() { Get().Enable(); }
        public void Disable() { Get().Disable(); }
        public bool enabled => Get().enabled;
        public static implicit operator InputActionMap(JumpingActions set) { return set.Get(); }
        public void AddCallbacks(IJumpingActions instance)
        {
            if (instance == null || m_Wrapper.m_JumpingActionsCallbackInterfaces.Contains(instance)) return;
            m_Wrapper.m_JumpingActionsCallbackInterfaces.Add(instance);
            @Jump.started += instance.OnJump;
            @Jump.performed += instance.OnJump;
            @Jump.canceled += instance.OnJump;
        }

        private void UnregisterCallbacks(IJumpingActions instance)
        {
            @Jump.started -= instance.OnJump;
            @Jump.performed -= instance.OnJump;
            @Jump.canceled -= instance.OnJump;
        }

        public void RemoveCallbacks(IJumpingActions instance)
        {
            if (m_Wrapper.m_JumpingActionsCallbackInterfaces.Remove(instance))
                UnregisterCallbacks(instance);
        }

        public void SetCallbacks(IJumpingActions instance)
        {
            foreach (var item in m_Wrapper.m_JumpingActionsCallbackInterfaces)
                UnregisterCallbacks(item);
            m_Wrapper.m_JumpingActionsCallbackInterfaces.Clear();
            AddCallbacks(instance);
        }
    }
    public JumpingActions @Jumping => new JumpingActions(this);

    // Attack
    private readonly InputActionMap m_Attack;
    private List<IAttackActions> m_AttackActionsCallbackInterfaces = new List<IAttackActions>();
    private readonly InputAction m_Attack_Attack;
    public struct AttackActions
    {
        private @Controls m_Wrapper;
        public AttackActions(@Controls wrapper) { m_Wrapper = wrapper; }
        public InputAction @Attack => m_Wrapper.m_Attack_Attack;
        public InputActionMap Get() { return m_Wrapper.m_Attack; }
        public void Enable() { Get().Enable(); }
        public void Disable() { Get().Disable(); }
        public bool enabled => Get().enabled;
        public static implicit operator InputActionMap(AttackActions set) { return set.Get(); }
        public void AddCallbacks(IAttackActions instance)
        {
            if (instance == null || m_Wrapper.m_AttackActionsCallbackInterfaces.Contains(instance)) return;
            m_Wrapper.m_AttackActionsCallbackInterfaces.Add(instance);
            @Attack.started += instance.OnAttack;
            @Attack.performed += instance.OnAttack;
            @Attack.canceled += instance.OnAttack;
        }

        private void UnregisterCallbacks(IAttackActions instance)
        {
            @Attack.started -= instance.OnAttack;
            @Attack.performed -= instance.OnAttack;
            @Attack.canceled -= instance.OnAttack;
        }

        public void RemoveCallbacks(IAttackActions instance)
        {
            if (m_Wrapper.m_AttackActionsCallbackInterfaces.Remove(instance))
                UnregisterCallbacks(instance);
        }

        public void SetCallbacks(IAttackActions instance)
        {
            foreach (var item in m_Wrapper.m_AttackActionsCallbackInterfaces)
                UnregisterCallbacks(item);
            m_Wrapper.m_AttackActionsCallbackInterfaces.Clear();
            AddCallbacks(instance);
        }
    }
    public AttackActions @Attack => new AttackActions(this);

    // Dodge
    private readonly InputActionMap m_Dodge;
    private List<IDodgeActions> m_DodgeActionsCallbackInterfaces = new List<IDodgeActions>();
    private readonly InputAction m_Dodge_Dodge;
    public struct DodgeActions
    {
        private @Controls m_Wrapper;
        public DodgeActions(@Controls wrapper) { m_Wrapper = wrapper; }
        public InputAction @Dodge => m_Wrapper.m_Dodge_Dodge;
        public InputActionMap Get() { return m_Wrapper.m_Dodge; }
        public void Enable() { Get().Enable(); }
        public void Disable() { Get().Disable(); }
        public bool enabled => Get().enabled;
        public static implicit operator InputActionMap(DodgeActions set) { return set.Get(); }
        public void AddCallbacks(IDodgeActions instance)
        {
            if (instance == null || m_Wrapper.m_DodgeActionsCallbackInterfaces.Contains(instance)) return;
            m_Wrapper.m_DodgeActionsCallbackInterfaces.Add(instance);
            @Dodge.started += instance.OnDodge;
            @Dodge.performed += instance.OnDodge;
            @Dodge.canceled += instance.OnDodge;
        }

        private void UnregisterCallbacks(IDodgeActions instance)
        {
            @Dodge.started -= instance.OnDodge;
            @Dodge.performed -= instance.OnDodge;
            @Dodge.canceled -= instance.OnDodge;
        }

        public void RemoveCallbacks(IDodgeActions instance)
        {
            if (m_Wrapper.m_DodgeActionsCallbackInterfaces.Remove(instance))
                UnregisterCallbacks(instance);
        }

        public void SetCallbacks(IDodgeActions instance)
        {
            foreach (var item in m_Wrapper.m_DodgeActionsCallbackInterfaces)
                UnregisterCallbacks(item);
            m_Wrapper.m_DodgeActionsCallbackInterfaces.Clear();
            AddCallbacks(instance);
        }
    }
    public DodgeActions @Dodge => new DodgeActions(this);

    // Use
    private readonly InputActionMap m_Use;
    private List<IUseActions> m_UseActionsCallbackInterfaces = new List<IUseActions>();
    private readonly InputAction m_Use_Use;
    public struct UseActions
    {
        private @Controls m_Wrapper;
        public UseActions(@Controls wrapper) { m_Wrapper = wrapper; }
        public InputAction @Use => m_Wrapper.m_Use_Use;
        public InputActionMap Get() { return m_Wrapper.m_Use; }
        public void Enable() { Get().Enable(); }
        public void Disable() { Get().Disable(); }
        public bool enabled => Get().enabled;
        public static implicit operator InputActionMap(UseActions set) { return set.Get(); }
        public void AddCallbacks(IUseActions instance)
        {
            if (instance == null || m_Wrapper.m_UseActionsCallbackInterfaces.Contains(instance)) return;
            m_Wrapper.m_UseActionsCallbackInterfaces.Add(instance);
            @Use.started += instance.OnUse;
            @Use.performed += instance.OnUse;
            @Use.canceled += instance.OnUse;
        }

        private void UnregisterCallbacks(IUseActions instance)
        {
            @Use.started -= instance.OnUse;
            @Use.performed -= instance.OnUse;
            @Use.canceled -= instance.OnUse;
        }

        public void RemoveCallbacks(IUseActions instance)
        {
            if (m_Wrapper.m_UseActionsCallbackInterfaces.Remove(instance))
                UnregisterCallbacks(instance);
        }

        public void SetCallbacks(IUseActions instance)
        {
            foreach (var item in m_Wrapper.m_UseActionsCallbackInterfaces)
                UnregisterCallbacks(item);
            m_Wrapper.m_UseActionsCallbackInterfaces.Clear();
            AddCallbacks(instance);
        }
    }
    public UseActions @Use => new UseActions(this);

    // GrapplingHook
    private readonly InputActionMap m_GrapplingHook;
    private List<IGrapplingHookActions> m_GrapplingHookActionsCallbackInterfaces = new List<IGrapplingHookActions>();
    private readonly InputAction m_GrapplingHook_Grapple;
    public struct GrapplingHookActions
    {
        private @Controls m_Wrapper;
        public GrapplingHookActions(@Controls wrapper) { m_Wrapper = wrapper; }
        public InputAction @Grapple => m_Wrapper.m_GrapplingHook_Grapple;
        public InputActionMap Get() { return m_Wrapper.m_GrapplingHook; }
        public void Enable() { Get().Enable(); }
        public void Disable() { Get().Disable(); }
        public bool enabled => Get().enabled;
        public static implicit operator InputActionMap(GrapplingHookActions set) { return set.Get(); }
        public void AddCallbacks(IGrapplingHookActions instance)
        {
            if (instance == null || m_Wrapper.m_GrapplingHookActionsCallbackInterfaces.Contains(instance)) return;
            m_Wrapper.m_GrapplingHookActionsCallbackInterfaces.Add(instance);
            @Grapple.started += instance.OnGrapple;
            @Grapple.performed += instance.OnGrapple;
            @Grapple.canceled += instance.OnGrapple;
        }

        private void UnregisterCallbacks(IGrapplingHookActions instance)
        {
            @Grapple.started -= instance.OnGrapple;
            @Grapple.performed -= instance.OnGrapple;
            @Grapple.canceled -= instance.OnGrapple;
        }

        public void RemoveCallbacks(IGrapplingHookActions instance)
        {
            if (m_Wrapper.m_GrapplingHookActionsCallbackInterfaces.Remove(instance))
                UnregisterCallbacks(instance);
        }

        public void SetCallbacks(IGrapplingHookActions instance)
        {
            foreach (var item in m_Wrapper.m_GrapplingHookActionsCallbackInterfaces)
                UnregisterCallbacks(item);
            m_Wrapper.m_GrapplingHookActionsCallbackInterfaces.Clear();
            AddCallbacks(instance);
        }
    }
    public GrapplingHookActions @GrapplingHook => new GrapplingHookActions(this);

    // SkillSelector
    private readonly InputActionMap m_SkillSelector;
    private List<ISkillSelectorActions> m_SkillSelectorActionsCallbackInterfaces = new List<ISkillSelectorActions>();
    private readonly InputAction m_SkillSelector_UseSkill;
    private readonly InputAction m_SkillSelector_NextSkill;
    private readonly InputAction m_SkillSelector_PreviousSkill;
    public struct SkillSelectorActions
    {
        private @Controls m_Wrapper;
        public SkillSelectorActions(@Controls wrapper) { m_Wrapper = wrapper; }
        public InputAction @UseSkill => m_Wrapper.m_SkillSelector_UseSkill;
        public InputAction @NextSkill => m_Wrapper.m_SkillSelector_NextSkill;
        public InputAction @PreviousSkill => m_Wrapper.m_SkillSelector_PreviousSkill;
        public InputActionMap Get() { return m_Wrapper.m_SkillSelector; }
        public void Enable() { Get().Enable(); }
        public void Disable() { Get().Disable(); }
        public bool enabled => Get().enabled;
        public static implicit operator InputActionMap(SkillSelectorActions set) { return set.Get(); }
        public void AddCallbacks(ISkillSelectorActions instance)
        {
            if (instance == null || m_Wrapper.m_SkillSelectorActionsCallbackInterfaces.Contains(instance)) return;
            m_Wrapper.m_SkillSelectorActionsCallbackInterfaces.Add(instance);
            @UseSkill.started += instance.OnUseSkill;
            @UseSkill.performed += instance.OnUseSkill;
            @UseSkill.canceled += instance.OnUseSkill;
            @NextSkill.started += instance.OnNextSkill;
            @NextSkill.performed += instance.OnNextSkill;
            @NextSkill.canceled += instance.OnNextSkill;
            @PreviousSkill.started += instance.OnPreviousSkill;
            @PreviousSkill.performed += instance.OnPreviousSkill;
            @PreviousSkill.canceled += instance.OnPreviousSkill;
        }

        private void UnregisterCallbacks(ISkillSelectorActions instance)
        {
            @UseSkill.started -= instance.OnUseSkill;
            @UseSkill.performed -= instance.OnUseSkill;
            @UseSkill.canceled -= instance.OnUseSkill;
            @NextSkill.started -= instance.OnNextSkill;
            @NextSkill.performed -= instance.OnNextSkill;
            @NextSkill.canceled -= instance.OnNextSkill;
            @PreviousSkill.started -= instance.OnPreviousSkill;
            @PreviousSkill.performed -= instance.OnPreviousSkill;
            @PreviousSkill.canceled -= instance.OnPreviousSkill;
        }

        public void RemoveCallbacks(ISkillSelectorActions instance)
        {
            if (m_Wrapper.m_SkillSelectorActionsCallbackInterfaces.Remove(instance))
                UnregisterCallbacks(instance);
        }

        public void SetCallbacks(ISkillSelectorActions instance)
        {
            foreach (var item in m_Wrapper.m_SkillSelectorActionsCallbackInterfaces)
                UnregisterCallbacks(item);
            m_Wrapper.m_SkillSelectorActionsCallbackInterfaces.Clear();
            AddCallbacks(instance);
        }
    }
    public SkillSelectorActions @SkillSelector => new SkillSelectorActions(this);

    // Use HP Flask
    private readonly InputActionMap m_UseHPFlask;
    private List<IUseHPFlaskActions> m_UseHPFlaskActionsCallbackInterfaces = new List<IUseHPFlaskActions>();
    private readonly InputAction m_UseHPFlask_UseHPFlask;
    public struct UseHPFlaskActions
    {
        private @Controls m_Wrapper;
        public UseHPFlaskActions(@Controls wrapper) { m_Wrapper = wrapper; }
        public InputAction @UseHPFlask => m_Wrapper.m_UseHPFlask_UseHPFlask;
        public InputActionMap Get() { return m_Wrapper.m_UseHPFlask; }
        public void Enable() { Get().Enable(); }
        public void Disable() { Get().Disable(); }
        public bool enabled => Get().enabled;
        public static implicit operator InputActionMap(UseHPFlaskActions set) { return set.Get(); }
        public void AddCallbacks(IUseHPFlaskActions instance)
        {
            if (instance == null || m_Wrapper.m_UseHPFlaskActionsCallbackInterfaces.Contains(instance)) return;
            m_Wrapper.m_UseHPFlaskActionsCallbackInterfaces.Add(instance);
            @UseHPFlask.started += instance.OnUseHPFlask;
            @UseHPFlask.performed += instance.OnUseHPFlask;
            @UseHPFlask.canceled += instance.OnUseHPFlask;
        }

        private void UnregisterCallbacks(IUseHPFlaskActions instance)
        {
            @UseHPFlask.started -= instance.OnUseHPFlask;
            @UseHPFlask.performed -= instance.OnUseHPFlask;
            @UseHPFlask.canceled -= instance.OnUseHPFlask;
        }

        public void RemoveCallbacks(IUseHPFlaskActions instance)
        {
            if (m_Wrapper.m_UseHPFlaskActionsCallbackInterfaces.Remove(instance))
                UnregisterCallbacks(instance);
        }

        public void SetCallbacks(IUseHPFlaskActions instance)
        {
            foreach (var item in m_Wrapper.m_UseHPFlaskActionsCallbackInterfaces)
                UnregisterCallbacks(item);
            m_Wrapper.m_UseHPFlaskActionsCallbackInterfaces.Clear();
            AddCallbacks(instance);
        }
    }
    public UseHPFlaskActions @UseHPFlask => new UseHPFlaskActions(this);

    // Use MP Flask
    private readonly InputActionMap m_UseMPFlask;
    private List<IUseMPFlaskActions> m_UseMPFlaskActionsCallbackInterfaces = new List<IUseMPFlaskActions>();
    private readonly InputAction m_UseMPFlask_UseMPFlask;
    public struct UseMPFlaskActions
    {
        private @Controls m_Wrapper;
        public UseMPFlaskActions(@Controls wrapper) { m_Wrapper = wrapper; }
        public InputAction @UseMPFlask => m_Wrapper.m_UseMPFlask_UseMPFlask;
        public InputActionMap Get() { return m_Wrapper.m_UseMPFlask; }
        public void Enable() { Get().Enable(); }
        public void Disable() { Get().Disable(); }
        public bool enabled => Get().enabled;
        public static implicit operator InputActionMap(UseMPFlaskActions set) { return set.Get(); }
        public void AddCallbacks(IUseMPFlaskActions instance)
        {
            if (instance == null || m_Wrapper.m_UseMPFlaskActionsCallbackInterfaces.Contains(instance)) return;
            m_Wrapper.m_UseMPFlaskActionsCallbackInterfaces.Add(instance);
            @UseMPFlask.started += instance.OnUseMPFlask;
            @UseMPFlask.performed += instance.OnUseMPFlask;
            @UseMPFlask.canceled += instance.OnUseMPFlask;
        }

        private void UnregisterCallbacks(IUseMPFlaskActions instance)
        {
            @UseMPFlask.started -= instance.OnUseMPFlask;
            @UseMPFlask.performed -= instance.OnUseMPFlask;
            @UseMPFlask.canceled -= instance.OnUseMPFlask;
        }

        public void RemoveCallbacks(IUseMPFlaskActions instance)
        {
            if (m_Wrapper.m_UseMPFlaskActionsCallbackInterfaces.Remove(instance))
                UnregisterCallbacks(instance);
        }

        public void SetCallbacks(IUseMPFlaskActions instance)
        {
            foreach (var item in m_Wrapper.m_UseMPFlaskActionsCallbackInterfaces)
                UnregisterCallbacks(item);
            m_Wrapper.m_UseMPFlaskActionsCallbackInterfaces.Clear();
            AddCallbacks(instance);
        }
    }
    public UseMPFlaskActions @UseMPFlask => new UseMPFlaskActions(this);
    private int m_KeyboardSchemeIndex = -1;
    public InputControlScheme KeyboardScheme
    {
        get
        {
            if (m_KeyboardSchemeIndex == -1) m_KeyboardSchemeIndex = asset.FindControlSchemeIndex("Keyboard");
            return asset.controlSchemes[m_KeyboardSchemeIndex];
        }
    }
    private int m_GamepadSchemeIndex = -1;
    public InputControlScheme GamepadScheme
    {
        get
        {
            if (m_GamepadSchemeIndex == -1) m_GamepadSchemeIndex = asset.FindControlSchemeIndex("Gamepad");
            return asset.controlSchemes[m_GamepadSchemeIndex];
        }
    }
    public interface IMovementActions
    {
        void OnMove(InputAction.CallbackContext context);
    }
    public interface IJumpingActions
    {
        void OnJump(InputAction.CallbackContext context);
    }
    public interface IAttackActions
    {
        void OnAttack(InputAction.CallbackContext context);
    }
    public interface IDodgeActions
    {
        void OnDodge(InputAction.CallbackContext context);
    }
    public interface IUseActions
    {
        void OnUse(InputAction.CallbackContext context);
    }
    public interface IGrapplingHookActions
    {
        void OnGrapple(InputAction.CallbackContext context);
    }
    public interface ISkillSelectorActions
    {
        void OnUseSkill(InputAction.CallbackContext context);
        void OnNextSkill(InputAction.CallbackContext context);
        void OnPreviousSkill(InputAction.CallbackContext context);
    }
    public interface IUseHPFlaskActions
    {
        void OnUseHPFlask(InputAction.CallbackContext context);
    }
    public interface IUseMPFlaskActions
    {
        void OnUseMPFlask(InputAction.CallbackContext context);
    }
}
